---
title: Encrypt Secrets in an etcd Database
owner: TKGI
---

This topic describes how to create and use a Kubernetes profile to encrypt a cluster's etcd database.

For more information and other uses of Kubernetes profiles, see [Using Kubernetes Profiles](./k8s-profiles.html).

## <a id='profile'></a> Create Kubernetes Profile

To create a new create Kubernetes profile: 

1. Create a new a base64-encoded, 32-byte random key string to use as a secret.  
    * On Linux or MacOS, you can generate the secret by running:  

        ```
        head -c 32 /dev/urandom | base64
        ```
	    The command will return a base64-encoded, 32-byte key string, for example: `jHc3NMp7s7T7JoJuZF7NUSkHVYCSikJCNJ+LrltbkJk=`

1. To create an encryption provider configuration file, create a file named `encryption-provider-config.yml` 
containing the following content:

	```
	apiVersion: apiserver.config.k8s.io/v1
	kind: EncryptionConfiguration
	resources:
	  - resources:
	    - secrets
	    providers:
	    - aescbc:

	        keys:
	        - name: key1
	          secret: BASE-64-ENCODED-SECRET
	    - identity: {}	          
	```
	Where `BASE-64-ENCODED-SECRET` is the secret key string created in the last step.

1. To create a Kubernetes profile configuration file that customizes the kube-apiserver using
your encryption provider configuration file, create a json file containing the following content:

	```
	{
	  "name": "PROFILE-TITLE",
	  "description": "PROFILE-DESC",
	  "customizations": [
	    {
	      "component": "kube-apiserver",
	      "arguments": {
	      },
	      "file-arguments": {
	        "encryption-provider-config": "/LOCAL-DIR/encryption-provider-config.yml"
	      }
	    }
	  ]
	}
	```
	Where:  
	* `PROFILE-TITLE` is the name of your profile, for example `profile1`.  
	* `PROFILE-DESC` is the description you want to use for the profile.  
	* `LOCAL-DIR` is the directory containing your encryption provider configuration file.  

1. To create a Kubernetes profile based on your profile configuration file, 
use the <%= vars.k8s_runtime_abbr %> CLI:

    ```
    tkgi create-k8s-profile PROFILE-PATH
    ```

    Where `PROFILE-PATH` is the path and filename of the json profile file you created in the last step.  
<br>
    For example:  
	<pre class="terminal">
	$ tkgi create-k8s-profile /tmp/profile1.json
	Kubernetes profile profile1 successfully created
	</pre>

## <a id='cluster'></a> Create Kubernetes Cluster

To create a Kubernetes cluster based on a Kubernetes profile:

1. To create a cluster based on a Kubernetes profile, use the <%= vars.k8s_runtime_abbr %> CLI:  

    ```
    tkgi create-cluster CLUSTER-NAME -e EXTERNAL-HOSTNAME -p small -n 1 --kubernetes-profile K8S-PROFILE
    ```

    Where:  
    * `CLUSTER-NAME` is the name to apply to the new cluster.  
    * `EXTERNAL-HOSTNAME` is the address to use to access Kubernetes API.  
    * `K8S-PROFILE` is the Kubernetes profile filename. 
    For more information, see [`tkgi create-cluster`](./cli/index.html#create-cluster) in _<%= vars.k8s_runtime_abbr %> CLI_.  

    Running this command restarts your kube-apiserver with your encryption provider configuration file 
    set as the `--encryption-provider-config` parameter.  
<br>
    For example:
    <pre class="terminal">
    $ tkgi create-cluster cluster1 -e cluster1-internal.com -p small -n 1 --kubernetes-profile profile1
    <%= vars.k8s_runtime_abbr %> Version:              1.9.0-build.1
    Name:                     cluster1
    K8s Version:              1.18.8
    Plan Name:                small
    UUID:                     22f78823-0b70-4684-be2f-8457d6f3b1f1
    Last Action:              CREATE
    Last Action State:        in progress
    Last Action Description:  Creating cluster
    Kubernetes Master Host:   cluster1-internal.com
    Kubernetes Master Port:   8443
    Worker Nodes:             1
    Kubernetes Master IP(s):  In Progress
    Network Profile Name:
    Kubernetes Profile Name:  profile1
    Tags:
    </pre>
	
## <a id='ensure-existing'></a> Ensure Existing Data is Encrypted

If you have existing data, the data has been stored without being encrypted. 

To encrypt your existing data:

1. Run the following:

    ```
    kubectl get secrets --all-namespaces -o json | kubectl replace -f -
    ```

    This command reads all secrets, applies encryption, and saves the data encrypted. 
    For more information, see [Ensure all secrets are encrypted](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#ensure-all-secrets-are-encrypted)
    in the Kubernetes documentation.  

1. Be sure to complete the steps in [Verify Your Data is Encrypted](verify-encryption).  

## <a id='verify-encryption'></a> Verify Your Data is Encrypted

After the kube-apiserver restarts, all existing data in its etcd database should be encrypted, 
and it should encrypt any new data that it stores.

To ensure the etcd data has been encrypted, create and store a new secret and then retrieve it:

1. To create and store a new secret:  

    ```
	kubectl create secret generic SECRET-NAME -n NAMESPACE --from-literal=KEY-NAME=KEY-VALUE
    ```

    Where:  
    * `SECRET-NAME` is the name to apply to the secret.  
    * `NAMESPACE` is the namespace
    * `KEY-NAME`
    * `KEY-VALUE` is the value to encrypt


    For example:

    <pre class="terminal">
	kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
	</pre>

    For more information, see [`create secret generic`]
    (https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-em-secret-generic-em-) 
    in the Kubernetes documentation.  

1. To read the new secret out of etcd, use the etcdctl command line:  

    ```
    ETCDCTL_API=3 etcdctl get /registry/secrets/default/SECRET-NAME [ETCD-ARGS] | hexdump -C
    ```
    Where:  
    * `SECRET-NAME` is the name to apply to the secret. 
    * `ETCD-ARGS` are the additional arguments for connecting to the etcd server.

	For example, if you SSH into your master node and with admin privileges you could run the following command to get the secret and view it. 
    <pre class="terminal">
	ETCDCTL_API=3 /var/vcap/jobs/etcd/bin/etcdctl get /registry/secrets/default/secret1
	</pre>

1. Verify the stored secret is prefixed with `k8s:enc:aescbc:v1:`. For example: 

    <pre class="terminal">
	master/3f9c5ca9-a2b1-469c-9007-6fdd0844a5ec:/var/vcap/bosh_ssh/bosh_2f4aaa514474422# ETCDCTL_API=3 /var/vcap/jobs/etcd/bin/etcdctl get /registry/secrets/default/secret1

	/registry/secrets/default/secret1
	k8s:enc:aescbc:v1:key1:����@�8�����A������2cM7������uL�/
	</pre>

	The `k8s:enc:aescbc:v1:` prefix indicates the `aescbc` provider has encrypted the resulting data.
	
1. To verify the secret is correctly decrypted when retrieved via the API:  

    ```
	kubectl describe secret secret1 -n default
    ```

	Should match `mykey: bXlkYXRh`, mydata is encoded, check [decoding a secret](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) to completely decode the secret.


## <a id='rotate'></a> Rotate Encryption Key for Secrets in etcd Database

This section describes how to use `encryption provider config` to
rotate key. 

Changing the secret without incurring downtime requires a multi-step
operation,
especially for a highly-available deployment running multiple kube-apiserver processes.

1. Generate a new key and add it as the second key entry for the
     current provider in your encryption-provider-config.yml `keys:` list:

	```
	apiVersion: apiserver.config.k8s.io/v1
	kind: EncryptionConfiguration
	resources:
	  - resources:
	    - secrets
	    providers:
	    - aescbc:
	        keys:
	        - name: key1
	          secret: jHc3NMp7s7T7JoJuZF7NUSkHVYCSikJCNJ+LrltbkJk=
	        - name: key2
	          secret: MNI7xeE48/1dH+pE5LLHblhId6AjbzdN2I6rubh8AfE=
	    - identity: {}	          
	```

1. Create a Kubernetes profile configuration file for `profile2` that references the modified `encryption-provider-config.yml`.

	```json
	{
	  "name": "profile2",
	  "description": "Testing profile two",
	  "customizations": [
	    {
	      "component": "kube-apiserver",
	      "arguments": { },
	      "file-arguments": {
	        "encryption-provider-config": "/tmp/encryption-provider-config.yml"
	      }
	    }
	  ]
	}
	```

1. Use the <%= vars.k8s_runtime_abbr %> CLI to create a profile based on the configuration file:
	<pre class="terminal">
	$ tkgi create-k8s-profile /tmp/profile2.json
	Kubernetes profile profile2 successfully created
  </pre>

1.  Update the cluster with this new profile `profile2`.

	<pre class="terminal">
	$ tkgi update-cluster cluster1 --kubernetes-profile profile2

	Update summary for cluster cluster1:
	Kubernetes Profile Name: profile2
	Are you sure you want to continue? (y/n): y
	Use 'tkgi cluster cluster1' to monitor the state of your cluster
  </pre>

  	This restarts kube-apiserver processes to ensure each server
can decrypt using the new key.

1. Edit the encryption provider configuration file so that it lists the new key
as the first entry in the `keys:`, swapping its position with the old key.

	```
	apiVersion: apiserver.config.k8s.io/v1
	kind: EncryptionConfiguration
	resources:
	  - resources:
	    - secrets
	    providers:
	    - aescbc:
	        keys:
	        - name: key2
	          secret: MNI7xeE48/1dH+pE5LLHblhId6AjbzdN2I6rubh8AfE=
	        - name: key1
	          secret: jHc3NMp7s7T7JoJuZF7NUSkHVYCSikJCNJ+LrltbkJk=
	    - identity: {}	          
	```

1. Create a Kubernetes profile configuration file for `profile3` that references the modified `encryption-provider-config.yml`.

	```
	{
	  "name": "profile3",
	  "description": "Testing profile three",
	  "customizations": [
	    {
	      "component": "kube-apiserver",
	      "arguments": { },
	      "file-arguments": {
	        "encryption-provider-config": "/tmp/encryption-provider-config.yml"
	      }
	    }
	  ]
	}
	```

1. Use the <%= vars.k8s_runtime_abbr %> CLI to create a profile based on the new Kubernetes profile configuration file:

	<pre class="terminal">
	$ tkgi create-k8s-profile /tmp/profile3.json
	Kubernetes profile profile2 successfully created
  </pre>

1.  Update the cluster with the new profile `profile3`. 

	<pre class="terminal">
	$ tkgi update-cluster cluster1 --kubernetes-profile profile3
	
	Update summary for cluster cluster1:
	Kubernetes Profile Name: profile3
	Are you sure you want to continue? (y/n): y
	Use 'tkgi cluster cluster1' to monitor the state of your cluster
	</pre>

	This restarts the kube-apiserver processes to ensure that
  each server now encrypts using the new key. 

1. To encrypt all existing secrets with the new key, run:
 `kubectl get secrets --all-namespaces -o json |
 kubectl replace -f - `

1. Back up etcd with the new key.  

1. Edit the `encryption-provider-config.yml` again to remove the old decryption key from the config `keys:` list:

	```
	apiVersion: apiserver.config.k8s.io/v1
	kind: EncryptionConfiguration
	resources:
	  - resources:
	    - secrets
	    providers:
	    - aescbc:
	        Keys:
	        - name: key2
	          secret: MNI7xeE48/1dH+pE5LLHblhId6AjbzdN2I6rubh8AfE=
	    - identity: {}	          
	```
1. Create a Kubernetes profile configuration file for `profile4` that references the modified `encryption-provider-config.yml`.

	```
	{
	  "name": "profile4",
	  "description": "Testing profile four",
	  "customizations": [
	    {
	      "component": "kube-apiserver",
	      "arguments": { },
	      "file-arguments": {
	        "encryption-provider-config": "/tmp/encryption-provider-config.yml"
	      }
	    }
	  ]
	}
	```

1. Use the <%= vars.k8s_runtime_abbr %> CLI to create a profile based on the new Kubernetes profile configuration file:

	<pre class="terminal">
	$ tkgi create-k8s-profile /tmp/profile4.json
	Kubernetes profile profile4 successfully created
  </pre>

1. Update the cluster with the new profile `profile4`. 

	<pre class="terminal">
	$ tkgi update-cluster cluster1 --kubernetes-profile profile4

	Update summary for cluster cluster1:
	Kubernetes Profile Name: profile4
	Are you sure you want to continue? (y/n): y
	Use 'tkgi cluster cluster1' to monitor the state of your cluster
	</pre>
	
1. Verify the stored secret is prefixed with `k8s:enc:aescbc:v1:key2`
which indicates the `aescbc` provider has encrypted the resulting data.

	<pre class="terminal">
	master/3f9c5ca9-a2b1-469c-9007-6fdd0844a5ec:/var/vcap/bosh\_ssh/bosh\_2f4aaa514474422\#
	ETCDCTL\_API=3 /var/vcap/packages/etcdctl/etcdctl --endpoints
	https://master-0.etcd.cfcr.internal:2379 --cert
	/var/vcap/jobs/etcd/config/etcdctl.crt --key
	/var/vcap/jobs/etcd/config/etcdctl.key --cacert
	/var/vcap/jobs/etcd/config/etcdctl-ca.crt get
	/registry/secrets/default/secret1

	/registry/secrets/default/secret1

	k8s:enc:aescbc:v1:key2:����@�8�����A������2cM7������uL�/
	</pre>

## <a id='decrypt'></a> Decrypt Secrets in the etcd Database

1. To disable encryption of data at rest, place the identity provider as the first entry in the encryption provider configuration file:

	```
	apiVersion: apiserver.config.k8s.io/v1
	kind: EncryptionConfiguration
	resources:
	  - resources:
	    - secrets
	    providers:
	    - identity: {}
	    - aescbc:
	        keys:
	        - name: key1
	          secret: <BASE 64 ENCODED SECRET>
	    - identity: {}	          
	```

1. Create a Kubernetes profile configuration file for `profile5` that references the modified `encryption-provider-config.yml`.

	```
	{
	  "name": "profile5",
	  "description": "Testing profile five",
	  "customizations": [
	    {
	      "component": "kube-apiserver",
	      "arguments": { },
	      "file-arguments": {
	        "encryption-provider-config": "/tmp/encryption-provider-config.yml"
	      }
	    }
	  ]
	}
	```

1. Use the <%= vars.k8s_runtime_abbr %> CLI to create a profile based on the modified Kubernetes profile configuration file:

	<pre class="terminal">
	$ tkgi create-k8s-profile /tmp/profile5.json
	Kubernetes profile profile5 successfully created
  </pre>
	
1.  Update the cluster with the new profile profile5:

	<pre class="terminal">
	$ tkgi update-cluster cluster1 --kubernetes-profile profile5

	Update summary for cluster cluster1:
	Kubernetes Profile Name: profile5
	Are you sure you want to continue? (y/n): y
	Use 'tkgi cluster cluster1' to monitor the state of your cluster
  </pre>

1. To force all secrets to be decrypted, run the command: `kubectl get secrets --all-namespaces -o json | kubectl replace -f -`.
